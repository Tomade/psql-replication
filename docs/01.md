# Run single PostgreSQL with stock configuration


At this stage we will be bringing up a single container, running a basic
PostgreSQL 9.6.x instance using the default configuration, but stored under
`/etc/postgresql` instead of the regular locationg (the PGDATA directory,
typically `/var/lib/postgresql/data`). The dockerfile for this image:

> `postgres-default.dockerfile`  

```
FROM postgres:9.6
RUN apt-get update && apt-get -y upgrade
RUN apt-get -y install vim less
RUN (echo "alias 'l=ls -l'" && echo "shopt -s autocd") >> /etc/bash.bashrc
ENV PGUSER=postgres
COPY postgresql-default.conf /etc/postgresql/postgresql.conf
CMD ["postgres", "-c", "config_file=/etc/postgresql/postgresql.conf"]
```
  
This dockerfile will create a new image starting with the official PostgreSQL
9.6 image, then updating the base OS layer and adding a couple of extra tools
and shell alias/options, before placing our `postgres.conf` in a location outside
PGDATA and then overriding the original launch command to make postgres use it.

To actually build and run our container, we'll take advantage of 
`docker-compose` with the following configuration file:
 
 > `docker-compose-default.yaml`
 ```yaml
version: '3'
services:
  primary:
    hostname: primary
    container_name: primary
    image: primary
    build:
      dockerfile: postgres-default.dockerfile
      context: .
    volumes:
      - vol-primary:/var/lib/postgresql/data
      
volumes:
  vol-primary:
```
This configuration will also create a named Docker volume for us 
(`vol-primary`) and mount it under the default PGDATA directory 
(`/var/lib/postgresql/data`).

To build the image and bring up the container, run:

```docker-compose -f docker-compose-default.yaml up --build -d ```

The very first time this operation will take a little while to build the 
image, but in future runs the base layers with the OS updates will have already 
been cached and newer images will be built far more quickly.

Once back at the shell, you should have your base PostgreSQL container running, 
using
the named volume we indicated. Verify with `docker ps` that you have a running
container called `primary`. Take a look at its logged messages with `docker logs
primary`, and try `docker volume ls` to list the new volume with its full name.

Now, try talking directly to the database with `docker exec -it primary
psql`. This will run the standard `psql` client from within the running
container and leave you at a command prompt, from which you can execute regular
SQL commands and the special psql extensions to create a new database, connect
to it, create tables, insert rows etc.
 
 To bring down the container, just run:
 
 ```docker-compose -f docker-compose-default.yaml down```

Notice that this will *not* delete your named volume where the actual 
database files are stored. If you run `docker-compose` again as you did 
above, your server will be restarted with all the database data exactly as 
you left it at the time you killed the old container. To completely remove 
all data together with the container, run `docker-compose down -v`. The `-v` 
option tells `docker-compose` to also remove the volumes defined in its 
coampose file. Alternatively, you could just run `docker volume rm` followed 
by the full name of the volume as listed by `docker volume ls` to purge the 
named volume.

Next: [Set up WAL archiving](docs/02.md)

