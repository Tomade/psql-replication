# Set up WAL archiving

PostgreSQL uses a well-known and very popular technique to guarantee
transactional integrity, called *Write Ahead Logging* or WAL for short.
Although a complete description of how WAL works is beyond the scope of this
tutorial, in short it means that any write operation is first recorded in a
journal file, which is later used when the server executes a checkpoint to
synchronize the data in the actual tablespaces on disk. In case of a server
crash, the data modified after the last checkpoint can be recovered from the
journal by replaying the "logged ahead" writes.

In practice the journal is split over a finite number of segments - normally
stored in the `pg_xlog` subdirectory of PGDATA - that are automatically
rotated and recycled by the server.  Each segment is normally of 16MB in size
and their number is determined by the values of a few configuration
parameters, as well as (starting with PostgreSQL 9.6) dynamically adjusted on
the basis of the moving average of the write load sustained.

We can however activate an additional functionality, known as "WAL
archiving". The idea is that before recycling a WAL segment, we make a copy of
it on a separate volume for archival purposes. The resulting set of
archived WAL segments enables us to perform point-in-time-recovery operations,
for example to restore the database as it was *20 minutes ago* - or as far
back as our archived journal allows us, starting with the last "base
backup". Additionally, WAL archiving is necessary to set up replication
towards a standby server, as we will see a little later.

In the following, we will show how to enable WAL archiving. We will first set
up a new named Docker volume to archive the WAL files, then tell PostgreSQL
about it and how to put his log files in it.

Creating the volume and making it available to our container can be done by
simply declaring it in our docker-compose file:

>`docker-compose-archiving.yaml
```yaml
